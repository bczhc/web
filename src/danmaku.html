<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>test</title>
    <script src="https://code.jquery.com/jquery-3.6.0.js"></script>
</head>
<body>
<video src="court.mp4" controls></video>
</body>

<div id="d1"></div>

<style>
    video {
        width: 100%;
        height: 100%;
    }

    div {
        font-weight: bold;
        font-size: 25px;
        position: absolute;
        top: 0;
        left: 100%;
        display: block;
        white-space: nowrap;
        color: white;
        text-shadow: rgb(0 0 0) 1px 0 1px, rgb(0 0 0) 0 1px 1px, rgb(0 0 0) 0 -1px 1px, rgb(0 0 0) -1px 0 1px;
    }
</style>

<script>

    const video = document.getElementsByTagName("video")[0]
    const danmaku = document.getElementById("d1");
    const body = document.getElementsByTagName("body")[0];

    class IOException {
        message

        constructor(msg) {
            this.message = msg
        }
    }

    $.ajax({
        url: "./messages.json",
        success: (data) => {
            readCallback(data);
        },
        error: (e) => {
            throw new IOException(e);
        },
        async: true
    })

    let dataStartTimestamp;
    let showStartTimestamp = dataStartTimestamp;
    let count = 0;
    let prevDanmaku = null;
    let sentDanmaku = [];

    function readCallback(data) {

        dataStartTimestamp = data[0]["ctime"];
        video.addEventListener("seeked", () => {
            const currentTime = video.currentTime;
            showStartTimestamp = dataStartTimestamp + currentTime;

            prevDanmaku.interrupt();
            const oldDanmakuNodes = document.getElementsByClassName("danmaku");
            for (let oldDanmakuNode of oldDanmakuNodes) {
                oldDanmakuNode.remove();
            }
            prevDanmaku = startDanmaku(data);
        });

        video.addEventListener("pause", () => {
            for (let o of sentDanmaku) {
                o.pause();
            }
        });
        video.addEventListener("play", () => {

            if (prevDanmaku == null) {
                startDanmaku(data);


            }

            for (let o of sentDanmaku) {
                if (o.started) {
                    o.resume();
                } else {
                    o.start();
                }
            }
        });
    }

    function startDanmaku(data) {
        let prevTimestamp = showStartTimestamp;
        let interrupted = false;
        (async () => {
            for (const msg of data) {

                const timestamp = msg["ctime"];
                if (timestamp < showStartTimestamp) continue;

                const delay = timestamp - prevTimestamp;
                prevTimestamp = timestamp;
                await sleep(delay * 1000);
                if (interrupted) {
                    return;
                }
                let sent = sendDanmaku(msg["message"])
                console.log("send: ", sent);
                sentDanmaku.push(sent);
            }
        })();

        return {
            interrupt: () => {
                interrupted = true;
            }
        }
    }

    function sendDanmaku(message) {
        let newDanmaku = danmaku.cloneNode(true);
        newDanmaku.id = `d${count}`;
        ++count;
        newDanmaku.innerText = message;
        newDanmaku.className = "danmaku";
        let top = Random.generate(0, window.innerHeight);
        newDanmaku.style.top = `${top}px`

        return new Moving(newDanmaku, false);
    }

    class Moving {
        paused = false
        i = 0;
        danmakuNode;
        started = false;

        constructor(danmakuNode, start) {
            this.danmakuNode = danmakuNode;
            if (start) {
                this.start();
                this.started = true;
            }
        }

        startPositionUpdate() {
            (async () => {
                for (; this.i >= -2000; this.i -= 2) {
                    if (this.paused) {
                        return;
                    }
                    this.#updatePosition(this.i);
                    await sleep(10);
                }
                this.danmakuNode.remove();
            })();
        }

        start() {
            body.appendChild(this.danmakuNode);
            this.startPositionUpdate();
            this.started = true;
        }

        pause() {
            this.paused = true;
        }

        resume() {
            this.paused = false;
            this.startPositionUpdate();
        }

        #updatePosition(translateX) {
            this.danmakuNode.style.transform = `translateX(${translateX}px)`;
        }
    }

    function sleep(millis) {
        return new Promise(resolve => {
            setTimeout(() => {
                resolve();
            }, millis);
        });
    }

    class Random {
        static generate(min, max) {
            return Math.round((Math.round(Math.random() * (max - min)) + min));
        }
    }
</script>

</html>